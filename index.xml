<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daniel J. H.</title>
    <link>https://daniel-j-h.github.io/</link>
    <description>Recent content on Daniel J. H.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    
    <lastBuildDate>Sun, 22 Mar 2015 13:05:45 CET</lastBuildDate>
    <atom:link href="https://daniel-j-h.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Distributed Search Engine with Nanomsg and Bond</title>
      <link>https://daniel-j-h.github.io/post/distributed-search-nanomsg-bond/</link>
      <pubDate>Sun, 22 Mar 2015 13:05:45 CET</pubDate>
      
      <guid>https://daniel-j-h.github.io/post/distributed-search-nanomsg-bond/</guid>
      <description>

&lt;p&gt;Exploring Microsoft&amp;rsquo;s open source Bond framework by building a distributed search engine.
I&amp;rsquo;m using bond for serialization/deserialization and nanomsg for communication.&lt;/p&gt;

&lt;p&gt;The source for this C++14 project is located at: &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch&#34;&gt;https://github.com/daniel-j-h/DistributedSearch&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;motivation:1b84be3312b0ca180481a342bee08b53&#34;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;A few weeks ago Microsoft open sourced Bond, a cross-platform framework for serialization/deserialization, similar to Google&amp;rsquo;s Protocol Buffers or Cap&amp;rsquo;n Proto. I have some experience with Cap&amp;rsquo;n Proto in particular, so this weekend I wanted to give Bond a try, since I had a few hours to spare.&lt;/p&gt;

&lt;h3 id=&#34;a-distributed-search-engine:1b84be3312b0ca180481a342bee08b53&#34;&gt;A Distributed Search Engine&lt;/h3&gt;

&lt;p&gt;Rob Pike introduced Go&amp;rsquo;s concurrency patterns with an example of a Google-inspired search.
The slides &lt;a href=&#34;https://talks.golang.org/2012/concurrency.slide#42&#34;&gt;are still available&lt;/a&gt; (please quickly skim slides 42-52) and the talk is also on Youtube. Let&amp;rsquo;s pick up this idea and implement it!&lt;/p&gt;

&lt;p&gt;The approach taken is roughly as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Query multiple services concurrently: for web results, video results, news and so on&lt;/li&gt;
&lt;li&gt;Gather the results, merge and show them to the user&lt;/li&gt;
&lt;li&gt;Replicate the services and query the replicas, too&lt;/li&gt;
&lt;li&gt;Do not wait forever, set timeouts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is the general idea. For more information please see the talk mentioned above.&lt;/p&gt;

&lt;p&gt;Now this project consists of the following. The communication part, for sending requests and receiving responses. I&amp;rsquo;m using nanomsg for this.
But first we have to serialize/deserialize our requests, i.e. the keyword to search for and the matches we receive from the services. I&amp;rsquo;m using Bond for this.&lt;/p&gt;

&lt;h2 id=&#34;nanomsg:1b84be3312b0ca180481a342bee08b53&#34;&gt;Nanomsg&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://nanomsg.org/&#34;&gt;nanomsg&lt;/a&gt; is a communication library, designed to provide you with patterns, such as Pub/Sub, Req/Rep, the Survey pattern and more.
You may be familiar with ZeroMQ, nanomsg is more or less the same with a few exceptions. I&amp;rsquo;m using nanomsg since I&amp;rsquo;m already familiar with it.&lt;/p&gt;

&lt;p&gt;Now we design our distributed search engine as follows: a Search service issues user-provided queries concurrently against the WebSearch service, the VideoSearch service and so on. The results are then merged and shown to the user. For this we&amp;rsquo;re using nanomsg&amp;rsquo;s &lt;a href=&#34;http://nanomsg.org/v0.4/nn_survey.7.html&#34;&gt;Survey pattern&lt;/a&gt;.
The Survey pattern sends messages to multiple locations and gathers the responses. For our simple project this is good enough, but having a single Surveyor is not the best idea and you probably want to think about how to factor this into the design.&lt;/p&gt;

&lt;h3 id=&#34;surveyor:1b84be3312b0ca180481a342bee08b53&#34;&gt;Surveyor&lt;/h3&gt;

&lt;p&gt;With the Survey pattern the so called Surveyor (our user-facing Search service) has to &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L28-L37&#34;&gt;bind to the endpoint&lt;/a&gt;, on which so called Respondents connect to.
The Surveyor also sets a timeout after which the survey is over and subsequent results coming in are discarded for this particular survey.&lt;/p&gt;

&lt;p&gt;For every user query the Surveyor now does the following.
Initially &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L57-L58&#34;&gt;broadcast the request to the Respondents&lt;/a&gt;.
Then &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L70&#34;&gt;gather all results from the Respondents&lt;/a&gt; as long as the timeout has not expired.&lt;/p&gt;

&lt;h3 id=&#34;respondents:1b84be3312b0ca180481a342bee08b53&#34;&gt;Respondents&lt;/h3&gt;

&lt;p&gt;Respondents (our WebSearch service, ImageSearch service, and so on) &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L100-L104&#34;&gt;connect to the endpoint&lt;/a&gt;, indicating they want to participate in surveys.
For this the services spin in an eventloop, waiting for requests to process.
Once they &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L121-L122&#34;&gt;receive a request&lt;/a&gt; they handle it (i.e. they search for results) and &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L147-L148&#34;&gt;send matches for this query back&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;
            Surveyor
         bind(localhost)
        /               \
       /                 \
      /                   \
connect(Surveyor)    connect(Surveyor)
   Respondent           Respondent

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the basic communication is set up, let&amp;rsquo;s do the serialization/deserialization part.&lt;/p&gt;

&lt;h2 id=&#34;bond:1b84be3312b0ca180481a342bee08b53&#34;&gt;Bond&lt;/h2&gt;

&lt;p&gt;Using &lt;a href=&#34;https://github.com/Microsoft/bond&#34;&gt;Microsoft&amp;rsquo;s Bond framework&lt;/a&gt;, we&amp;rsquo;re able to serialize and deserialize our messages (i.e. the keyword to search for and the matches we receive) before sending them over the wire.
For this we &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Messages.bond&#34;&gt;define our messages&lt;/a&gt; in a .bond schema.
The bond schema compiler now &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Makefile#L5-L6&#34;&gt;lets us generate stubs&lt;/a&gt; from this schema and they are included in the source repository.
You probably want to augment the messages with more information, such as timestamps, ratings, and so on. For this project a simple schema is good enough.&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s interesting now is the fact that the bond compiler is also able to spit out Python and C# stubs, which should make it possible to implement the Surveyor and Respondents in other languages, too. But I did not try this, yet.&lt;/p&gt;

&lt;h3 id=&#34;serialization:1b84be3312b0ca180481a342bee08b53&#34;&gt;Serialization&lt;/h3&gt;

&lt;p&gt;Now what the Surveyor (our user-facing search service) does is to &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L47-L54&#34;&gt;serialize the user-provided keyword&lt;/a&gt; before handing it over to nanomsg.
The Respondents (our WebSearch service, ImageSearch service, and so on) also &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L138-L145&#34;&gt;serialize their results&lt;/a&gt; before sending them back to us.&lt;/p&gt;

&lt;h3 id=&#34;deserialization:1b84be3312b0ca180481a342bee08b53&#34;&gt;Deserialization&lt;/h3&gt;

&lt;p&gt;For every query the Surveyor sends it has to &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L76-L80&#34;&gt;deserialize the responses&lt;/a&gt; nanomsg hands us during the survey.
The respondents similarly have to first &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L129-L133&#34;&gt;deserialize the keyword&lt;/a&gt; the Surveyor sends us.&lt;/p&gt;

&lt;p&gt;The types we used in the schema now integrate perfectly into the language. Therefore &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L82-L83&#34;&gt;merging responses&lt;/a&gt; on the Surveyor side is quite easy, using set semantics. &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Service.h#L139&#34;&gt;Populating&lt;/a&gt; the data structure with responses on the Respondent&amp;rsquo;s side can be done in the same way.&lt;/p&gt;

&lt;p&gt;Both serialization and deserialization are quite easy with Bond. Especially the (bytes, size)-tuple handling as required when interacting with nanomsg is not as bad as it was with Cap&amp;rsquo;n Proto.
Fortunately Kenton Varda improved the Cap&amp;rsquo;n Proto library in this regard, after &lt;a href=&#34;https://groups.google.com/forum/#!msg/capnproto/viZXnQ5iN50/B-hSgZ1yLWUJ&#34;&gt;a discussion on the mailinglist&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;putting-it-all-together:1b84be3312b0ca180481a342bee08b53&#34;&gt;Putting It All Together&lt;/h2&gt;

&lt;p&gt;With the serialization/deserialization and communication part done, all we have to do is put the pieces together.
That is, wrap what we built and provide a few ways of customization.&lt;/p&gt;

&lt;p&gt;The user-facing Search service &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/Search.cc#L10-L20&#34;&gt;interacts with the user and queries the services&lt;/a&gt;.
The search services &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/62a84caa478b3421e275d57ad0311c879ff89b51/WebSearch.cc#L9-L20&#34;&gt;wait for queries and handle them&lt;/a&gt; by sending dummy results for now.
Now let&amp;rsquo;s take a look at what we just built!&lt;/p&gt;

&lt;p&gt;Spin up the user-facing Search service and try issuing queries against it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./Search
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Search&amp;gt;
How many horns does a unicorn have?

Results&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No results. Right, we do not have any search service running. Let&amp;rsquo;s spin up a few:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./WebSearch
./VideoSearch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Resulting in the following service tree:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;           Search
          /      \
    WebSearch  VideoSearch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And interact with the user interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Search&amp;gt;
How many horns does a unicorn have?

Results&amp;gt;
 * First Video Result
 * First Web Result
 * Second Video Result
 * Second Web Result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! We get results back from those two services, without even noticing the connection establishment and communication done in the background during which our program was active at all time.&lt;/p&gt;

&lt;h3 id=&#34;communication-guarantees:1b84be3312b0ca180481a342bee08b53&#34;&gt;Communication Guarantees&lt;/h3&gt;

&lt;p&gt;Now what makes this even more awesome is that nanomsg guarantees us a handful of nice properties.
For example, our user-facing Search service does not care about what services are currently available.
You are also able to disconnect or re-connect any service at any time and the user only sees this in the results available.
This also allows us to start up e.g. multiple WebSearch service replicas in case some are too slow to respond within the timout.
Finally, nanomsg also &lt;a href=&#34;http://nanomsg.org/v0.1/nn_setsockopt.3.html&#34;&gt;handles auto-reconnects&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Furthermore we do not depend on the transport used. Check this out for a local IPC engine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./Search &amp;quot;ipc:///tmp/search.ipc&amp;quot;
./WebSearch &amp;quot;ipc:///tmp/search.ipc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;recursively-building-service-trees:1b84be3312b0ca180481a342bee08b53&#34;&gt;Recursively Building Service Trees&lt;/h3&gt;

&lt;p&gt;Throughout this project we assumed having a single Surveyor and multiple Respondents attached to it.
But what if a Respondent, e.g. a WebSearch service, has to query multiple WebSearch services recursively itself.
In this case, the Respondent also becomes a Surveyor for its local Respondents. This makes it possible to recursively build a tree of services.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/commit/84c361d336033b5a669b7b37ccc3b0773cb62b54#diff-3&#34;&gt;Introducing&lt;/a&gt; the RecursiveSearch service. The idea is the following: both &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/84c361d336033b5a669b7b37ccc3b0773cb62b54/RecursiveSearch.cc#L10-L11&#34;&gt;bind an connect to endpoints&lt;/a&gt;. The bind endpoint specifies the location Respondents further down the tree have to connect to. The connect endpoint specifies where to send the responses from those Respondents. By &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch/blob/84c361d336033b5a669b7b37ccc3b0773cb62b54/RecursiveSearch.cc#L13-L24&#34;&gt;passing on the request&lt;/a&gt; to all attached services we therefore act as a proxy, broadcasting the request to the Respondents attached to us. To guarantee timely delivery of results up the tree, the survey&amp;rsquo;s timeout has to be smaller going down the tree. Leveraging the abstractions built so far makes an implementation possible in only a few lines of code.&lt;/p&gt;

&lt;p&gt;We are now able to recursively build a tree of services:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./Search &amp;quot;tcp://*:9995&amp;quot;
./VideoSearch &amp;quot;tcp://localhost:9995&amp;quot;
./RecursiveSearch &amp;quot;tcp://*:9996&amp;quot; &amp;quot;tcp://localhost:9995&amp;quot;
./WebSearch &amp;quot;tcp://localhost:9996&amp;quot;
./ImageSearch &amp;quot;tcp://localhost:9996&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Resulting in the following service tree:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;           Search
          /      \
  VideoSearch   RecursiveSearch
                 /           \
	     WebSearch    ImageSearch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this setup, Search is the tree&amp;rsquo;s root, with VideoSearch and RecursiveSearch attached to it and WebSearch attached to the RecursiveSearch node. Attaching more services can be done transparently on each layer of the tree. Just attach them to the subtree&amp;rsquo;s specific root-service.&lt;/p&gt;

&lt;p&gt;If you try the recursive example on a single machine, you have to change the port for each layer, otherwise there would be no way to distinguish the root from internal tree nodes. To be more precise, each subtree&amp;rsquo;s root has to bind to a different port.&lt;/p&gt;

&lt;h2 id=&#34;summary:1b84be3312b0ca180481a342bee08b53&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In building a distributed search engine you hopefully learnt something about communication and serialization.
Using nanomsg and its Survey pattern makes the communication part quite easy.
Bond makes the serialization and deserialization part simple to implement.&lt;/p&gt;

&lt;p&gt;The source is hosted on GitHub: &lt;a href=&#34;https://github.com/daniel-j-h/DistributedSearch&#34;&gt;https://github.com/daniel-j-h/DistributedSearch&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Gentle Introduction To Geospatial Analysis</title>
      <link>https://daniel-j-h.github.io/post/gentle-introduction-postgis/</link>
      <pubDate>Sun, 01 Feb 2015 10:39:49 CET</pubDate>
      
      <guid>https://daniel-j-h.github.io/post/gentle-introduction-postgis/</guid>
      <description>

&lt;p&gt;This is meant as a gentle introduction into geospatial analysis.&lt;br /&gt;
We&amp;rsquo;re going to use OpenStreetMap datasets and work on PostgreSQL with the PostGIS extension.&lt;/p&gt;

&lt;h2 id=&#34;requirements:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;Requirements&lt;/h2&gt;

&lt;p&gt;For our geospatial analysis we need a few packages for importing, querying and exporting the datasets.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PostgreSQL&lt;/li&gt;
&lt;li&gt;PostGIS&lt;/li&gt;
&lt;li&gt;osm2pgsql&lt;/li&gt;
&lt;li&gt;ogr2ogr&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Install the requirements from your package manager.
For reference: my system is Debian GNU/Linux 8.0 (jessie):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;aptitude install postgresql-9.4 postgis osm2pgsql gdal-bin
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;preparing-the-database:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;Preparing The Database&lt;/h2&gt;

&lt;p&gt;As user postgres (i.e. sudo su postgres) create a new user playground, a new table playground and activate the PostGIS extension:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;createuser playground
createdb --owner playground gis
psql --dbname=gis --command &#39;create extension postgis;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;importing-openstreetmap-datasets:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;Importing OpenStreetMap Datasets&lt;/h2&gt;

&lt;p&gt;Geofabrik hosts OpenStreetMap dumps at &lt;a href=&#34;http://download.geofabrik.de&#34;&gt;http://download.geofabrik.de&lt;/a&gt;&lt;br /&gt;
I highly recommend starting with a small dataset first. We&amp;rsquo;re using sweden-latest.osm.pbf here.&lt;/p&gt;

&lt;p&gt;Import the dataset into Postgres. This creates relations and fills the database appropriately for efficient querying:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;osm2pgsql --create --database gis --latlong --slim --cache 4096 --username playground --password --number-processes 4 --multi-geometry --disable-parallel-indexing sweden-latest.osm.pbf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See the osm2pgsql manpage; you may want to change a few parameters e.g. the cache size.&lt;/p&gt;

&lt;p&gt;Hint: this is I/O bound from what I can tell (check iotop, htop), so your cpus won&amp;rsquo;t help much after a few minutes.
In case you don&amp;rsquo;t have a lot of memory you may want to temporarily lower the swappiness before importing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo sysctl vm.swappiness=10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Warning: importing with the latlong switch means we&amp;rsquo;re using the Spacial Reference System Id 4326 (WGS 84, EPSG:4326), therefore the units are in degree.
We have to cast the geometry type to the geography type if we want to work with meters. Just keep this in mind.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&#34;http://wiki.openstreetmap.org/wiki/Osm2pgsql&#34;&gt;http://wiki.openstreetmap.org/wiki/Osm2pgsql&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;exporting-query-results-as-geojson:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;Exporting Query Results As GeoJSON&lt;/h2&gt;

&lt;p&gt;ogr2ogr is able to issue queries against PostgreSQL, generating GeoJSON&amp;rsquo;s FeatureCollections and inserting your gemometry with description on the fly. See the example exports below for how this can be done. Other formats are available, too.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t want to use ogr2ogr you have to assemble GeoJSON from primitives such as points and lines yourself.
You&amp;rsquo;re then able to use the exported GeoJSON files as data source e.g. for Mapbox.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&#34;http://www.gdal.org/ogr2ogr.html&#34;&gt;http://www.gdal.org/ogr2ogr.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In the following I&amp;rsquo;m using Mapbox for visualization (as long as my data limit is not reached).&lt;/p&gt;

&lt;h2 id=&#34;resources-for-working-on-the-database:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;Resources For Working On The Database&lt;/h2&gt;

&lt;p&gt;Here are two good starting points for working on the database.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Database schema: &lt;a href=&#34;http://wiki.openstreetmap.org/wiki/Osm2pgsql/schema&#34;&gt;http://wiki.openstreetmap.org/wiki/Osm2pgsql/schema&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Map Features: &lt;a href=&#34;http://wiki.openstreetmap.org/wiki/Map_Features&#34;&gt;http://wiki.openstreetmap.org/wiki/Map_Features&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scan the Map Features quickly for what is available.
In the following we&amp;rsquo;re doing a few queries against those features.&lt;/p&gt;

&lt;h2 id=&#34;queries-against-features-and-polygons:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;Queries Against Features And Polygons&lt;/h2&gt;

&lt;p&gt;Connect to the database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;psql --dbname=gis --username=playground
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see what kind of relations and columns are available:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;\d
\d planet_osm_point
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Helpful PostGIS functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ST_AsGeoJSON on the geometry returns geojson&lt;/li&gt;
&lt;li&gt;ST_{XMin,YMin} on the geometry returns latlong&lt;/li&gt;
&lt;li&gt;ST_DWithin, ST_Distance and other for filtering and measurements&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See &lt;a href=&#34;http://postgis.net/docs/manual-2.1/reference.html&#34;&gt;http://postgis.net/docs/manual-2.1/reference.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hints for doing queries:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Limit your query while exploring the dataset, but don&amp;rsquo;t forget to unset the limit for exporting.&lt;/li&gt;
&lt;li&gt;The column&amp;rsquo;s type is text in almost all cases, check for number &amp;lsquo;^[0-9]+$&amp;rsquo; and cast; in order by clauses, too&lt;/li&gt;
&lt;li&gt;use CTRL-A/CTRL+E to jump to the left/right in psql, CTRL+L to clear screen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now let&amp;rsquo;s do a few queries!&lt;/p&gt;

&lt;h3 id=&#34;all-airports:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;All Airports&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s search for all airports in the dataset.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scroll through Map Features, find aerialways: &lt;a href=&#34;http://wiki.openstreetmap.org/wiki/Map_Features#Aerialway&#34;&gt;http://wiki.openstreetmap.org/wiki/Map_Features#Aerialway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Aeroway tag: &lt;a href=&#34;http://wiki.openstreetmap.org/wiki/Key:aeroway&#34;&gt;http://wiki.openstreetmap.org/wiki/Key:aeroway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Aerodrome value: &lt;a href=&#34;http://wiki.openstreetmap.org/wiki/Tag:aeroway%3Daerodrome&#34;&gt;http://wiki.openstreetmap.org/wiki/Tag:aeroway%3Daerodrome&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Warning: aerodrome is strictly speaking not only for airports. There are definitely a few missing, e.g. near Umeå, too.&lt;/p&gt;

&lt;p&gt;Nodes with tags are stored in the planet_osm_point relation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT name,
       ST_AsGeoJSON(way) AS geojson
FROM planet_osm_point
WHERE aeroway=&#39;aerodrome&#39;
ORDER BY name LIMIT 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;        name        |                        geojson                         
--------------------+--------------------------------------------------------
 Ålleberg Airport   | {&amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[13.6031192,58.1354088]}
 Älvsbyn Airport    | {&amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[21.0611,65.6456985]}
 Anderstorp Airport | {&amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[13.5993996,57.2641983]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice! Now we either assemble a GeoJSON document manually from all the rows or we simply use ogr2ogr:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ogr2ogr -f &amp;quot;GeoJSON&amp;quot; airports.geojson -t_srs EPSG:4326 PG:&amp;quot;dbname=&#39;gis&#39; user=&#39;playground&#39; password=&#39;playground&#39;&amp;quot; -s_srs EPSG:4326 -sql &amp;quot;select name, way from planet_osm_point where aeroway=&#39;aerodrome&#39; order by name;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ogr2ogr is quite clever and assembles GeoJSON from your geometries and description itself.&lt;/p&gt;

&lt;iframe width=&#39;100%&#39; height=&#39;500px&#39; frameBorder=&#39;0&#39; src=&#39;https://a.tiles.mapbox.com/v4/danieljh.l3jbdc17/attribution,zoompan,zoomwheel,geocoder,share.html?access_token=pk.eyJ1IjoiZGFuaWVsamgiLCJhIjoiTnNYb25JSSJ9.vYOnsuu1zeKcGW2nj0uJZw&#39;&gt;&lt;/iframe&gt;

&lt;h3 id=&#34;largest-cities:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;Largest Cities&lt;/h3&gt;

&lt;p&gt;Now what about the largest cities in the dataset.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Places: &lt;a href=&#34;http://wiki.openstreetmap.org/wiki/Places&#34;&gt;http://wiki.openstreetmap.org/wiki/Places&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Place tag: &lt;a href=&#34;http://wiki.openstreetmap.org/wiki/Key:place&#34;&gt;http://wiki.openstreetmap.org/wiki/Key:place&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;City: &lt;a href=&#34;http://wiki.openstreetmap.org/wiki/Tag:place%3Dcity&#34;&gt;http://wiki.openstreetmap.org/wiki/Tag:place%3Dcity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Population: &lt;a href=&#34;http://wiki.openstreetmap.org/wiki/Key:population&#34;&gt;http://wiki.openstreetmap.org/wiki/Key:population&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note: my dataset containes at least one entry where the population field has a value of &amp;ldquo;&amp;gt;50&amp;rdquo;, i.e. not a number.&lt;/p&gt;

&lt;p&gt;Keep this in mind in case you&amp;rsquo;re doing sums, averages or casts in general.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT sum(population::int) AS population
FROM planet_osm_point
WHERE population ~ &#39;^[0-9]+$&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; population 
------------
  15339409
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmmm&amp;hellip; interesting. This should be around 9-10 million.&lt;/p&gt;

&lt;p&gt;Now to the largest cities. The &amp;lsquo;city&amp;rsquo; value for the place tag already excludes smaller towns and villages.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT name,
       population::int,
       ST_AsGeoJSON(way) AS geojson
FROM planet_osm_point
WHERE place=&#39;city&#39;
  AND population ~ &#39;^[0-9]+$&#39;
ORDER BY population::int DESC LIMIT 5;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   name    | population |                        geojson                         
-----------+------------+--------------------------------------------------------
 Stockholm |     829417 | {&amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[18.0710935,59.3251172]}
 Göteborg  |     522259 | {&amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[11.9670171,57.7072326]}
 Malmö     |     303873 | {&amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[13.0001566,55.6052931]}
 Uppsala   |     128400 | {&amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[17.64112,59.8594126]}
 Västerås  |     110877 | {&amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[16.5463679,59.6110992]}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ogr2ogr -f &amp;quot;GeoJSON&amp;quot; cities.geojson -t_srs EPSG:4326 PG:&amp;quot;dbname=&#39;gis&#39; user=&#39;playground&#39; password=&#39;playground&#39;&amp;quot; -s_srs EPSG:4326 -sql &amp;quot;select name, population::int), way from planet_osm_point where place=&#39;city&#39; and population ~ &#39;^[0-9]+\$&#39; order by population::int desc;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;iframe width=&#39;100%&#39; height=&#39;500px&#39; frameBorder=&#39;0&#39; src=&#39;https://a.tiles.mapbox.com/v4/danieljh.l3jbk96g/attribution,zoompan,zoomwheel,geocoder,share.html?access_token=pk.eyJ1IjoiZGFuaWVsamgiLCJhIjoiTnNYb25JSSJ9.vYOnsuu1zeKcGW2nj0uJZw&#39;&gt;&lt;/iframe&gt;

&lt;h3 id=&#34;municipalities:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;Municipalities&lt;/h3&gt;

&lt;p&gt;Now we want the city&amp;rsquo;s boundaries e.g. the municipality as polygon.
The relation planet_osm_point only contains nodes with tags.
For the polygon data we have to query the relation planet_osm_polygon in addition.&lt;/p&gt;

&lt;p&gt;To do this, we cross join the nodes with the polygons and filter the largest cities as above.
We also check that our city is inside the municipality polygon.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT polygon.name,
       polygon.way
FROM planet_osm_point AS point
CROSS JOIN planet_osm_polygon AS polygon
WHERE point.place=&#39;city&#39;
  AND polygon.admin_level = &#39;7&#39;
  AND ST_Contains(polygon.way, point.way)
  AND point.population ~ &#39;^[0-9]+$&#39;
ORDER BY point.population::int DESC LIMIT 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For admin_level (7 is municipality) see &lt;a href=&#34;http://wiki.openstreetmap.org/wiki/Key:admin_level#admin_level&#34;&gt;http://wiki.openstreetmap.org/wiki/Key:admin_level#admin_level&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The output consists of polygons around the largest cities.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ogr2ogr -f &amp;quot;GeoJSON&amp;quot; boundaries.geojson -t_srs EPSG:4326 PG:&amp;quot;dbname=&#39;gis&#39; user=&#39;playground&#39; password=&#39;playground&#39;&amp;quot; -s_srs EPSG:4326 -sql &amp;quot;select polygon.name, polygon.way from planet_osm_point as point cross join planet_osm_polygon as polygon where point.place=&#39;city&#39; and polygon.admin_level = &#39;7&#39; and ST_Contains(polygon.way, point.way) and point.population ~ &#39;^[0-9]+\$&#39; order by point.population::int desc;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;iframe width=&#39;100%&#39; height=&#39;500px&#39; frameBorder=&#39;0&#39; src=&#39;https://a.tiles.mapbox.com/v4/danieljh.l3jc1lpa/attribution,zoompan,zoomwheel,geocoder,share.html?access_token=pk.eyJ1IjoiZGFuaWVsamgiLCJhIjoiTnNYb25JSSJ9.vYOnsuu1zeKcGW2nj0uJZw&#39;&gt;&lt;/iframe&gt;

&lt;h3 id=&#34;combining-airports-with-largest-cities:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;Combining Airports With Largest Cities&lt;/h3&gt;

&lt;p&gt;Now we want all airports that are within a distance X (in kilometers, 50km in this example query) around large cities.&lt;/p&gt;

&lt;p&gt;Warning: we imported with the latlong switch, which means SRID 4326.
Therefore the units are in degrees. We cast to the geography type for working with meters.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s cross join cities with airports and then filter by distance.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT city.name AS city,
       airport.name AS airport_name,
       ST_AsGeoJSON(airport.way) AS airport,
       ST_Distance(city.way::geography, airport.way::geography) AS distance
FROM planet_osm_point AS city
CROSS JOIN planet_osm_point AS airport
WHERE city.place=&#39;city&#39;
  AND city.population ~ &#39;^[0-9]+$&#39;
  AND airport.aeroway=&#39;aerodrome&#39;
  AND ST_DWithin(city.way::geography, airport.way::geography, 50000)
ORDER BY distance LIMIT 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    city     |      airport_name      |                        airport                         |    distance    
-------------+------------------------+--------------------------------------------------------+----------------
 Linköping   | Linköping City Airport | {&amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[15.658056,58.4080416]}  | 1970.028258466
 Halmstad    | Halmstad Flygplats     | {&amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[12.8216423,56.6865017]} |   2601.7448687
 Norrköping  | Norrköping Flygplats   | {&amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[16.2469701,58.5859972]} | 3338.144166465
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ogr2ogr -f &amp;quot;GeoJSON&amp;quot; nearest.geojson -t_srs EPSG:4326 PG:&amp;quot;dbname=&#39;gis&#39; user=&#39;playground&#39; password=&#39;playground&#39;&amp;quot; -s_srs EPSG:4326 -sql &amp;quot;select city.name as city, airport.name as airport_name, airport.way as airport, ST_Distance(city.way::geography, airport.way::geography) as distance from planet_osm_point as city cross join planet_osm_point as airport where city.place=&#39;city&#39; and city.population ~ &#39;^[0-9]+\$&#39; and airport.aeroway=&#39;aerodrome&#39; and ST_DWithin(city.way::geography, airport.way::geography, 50000) order by distance;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;iframe width=&#39;100%&#39; height=&#39;500px&#39; frameBorder=&#39;0&#39; src=&#39;https://a.tiles.mapbox.com/v4/danieljh.l3jc7m3p/attribution,zoompan,zoomwheel,geocoder,share.html?access_token=pk.eyJ1IjoiZGFuaWVsamgiLCJhIjoiTnNYb25JSSJ9.vYOnsuu1zeKcGW2nj0uJZw&#39;&gt;&lt;/iframe&gt;

&lt;h3 id=&#34;combining-geojson:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;Combining GeoJSON&lt;/h3&gt;

&lt;p&gt;Combining GeoJSON is also not a problem.
Municipality polygons and airports around large cities for example.&lt;/p&gt;

&lt;iframe width=&#39;100%&#39; height=&#39;500px&#39; frameBorder=&#39;0&#39; src=&#39;https://a.tiles.mapbox.com/v4/danieljh.l3jcdofm/attribution,zoompan,zoomwheel,geocoder,share.html?access_token=pk.eyJ1IjoiZGFuaWVsamgiLCJhIjoiTnNYb25JSSJ9.vYOnsuu1zeKcGW2nj0uJZw&#39;&gt;&lt;/iframe&gt;

&lt;h3 id=&#34;and-that-s-it:9b8c8843b531f194f39f9a90bfa38bfd&#34;&gt;And That&amp;rsquo;s It&lt;/h3&gt;

&lt;p&gt;This should give you an initial feel for what is possible with geospatial analysis.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>